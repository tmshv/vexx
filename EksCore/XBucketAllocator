#ifndef XRANDOMACCESSBLOCKALLOCATOR_H
#define XRANDOMACCESSBLOCKALLOCATOR_H

#include "XGlobal"
#include "XProperty"
#include "QHash"
#include "XUnorderedMap"
#include "XAllocatorBase"

#define Bit(index) 1 << index
#define Bits1To8   0x000000FF
#define Bits9To16  0x0000FF00
#define Bits17To24 0x00FF0000
#define Bits25To32 0xFF000000
#define FullMask (Bits1To8|Bits9To16|Bits17To24|Bits25To32)

X_DECLARE_MEMORY_LOGGER(EKSCORE_EXPORT, xTotalBucketAllocatorSize);

class XFixedSizeBucketAllocator
  {
public:

  class Bucket
    {
  XProperties:
    XProperty(Bucket *, next, setNext);

  public:
    Bucket(XAllocatorBase *allocator, xsize objectSize, xsize count)
        : _allocator(allocator), _count(count), _size(objectSize), _next(0)
      {
      xAssertIsAligned(objectSize);
      xAssert((count % 32) == 0);
      xAssert(_allocator);

      _alloc = (xuint8*)_allocator->alloc(_count*_size + (_count / 8) + X_ALIGN_BYTE_COUNT);
      _memory = X_ROUND_TO_ALIGNMENT(xuint8 *, _alloc);
      _masks = (xuint32*)((xuint8*)_memory + (_count*_size));

      for(xsize i=0, s=(_count/32); i<s; ++i)
        {
        _masks[i] = 0;
        }
      }

    ~Bucket()
      {
      _allocator->free(_alloc);
      }

    void *alloc()
      {
      xuint32 mask = 0;
      for(xsize i=0, s=(_count/32); i<s; ++i)
        {
        mask = _masks[i];
        if(mask != FullMask)
          {
          xuint8 spareBit = 0;
          if((mask&Bits1To8) != Bits1To8)
            {
            // spare in 1-8
            spareBit = findFirstSpareBit((xuint8)mask);
            }
          else if((mask&Bits9To16) != Bits9To16)
            {
            // spare in 9-16
            spareBit = findFirstSpareBit((xuint8)(mask >> 8)) + 8;
            }
          else if((mask&Bits17To24) != Bits17To24)
            {
            // spare in 17-24
            spareBit = findFirstSpareBit((xuint8)(mask >> 16)) + 16;
            }
          else
            {
            // spare in 25-32
            spareBit = findFirstSpareBit((xuint8)(mask >> 24)) + 24;
            }

          // mark spareBit as used.
          _masks[i] = mask|(1<<spareBit);
          return (void*)&(_memory[_size*((i*32)+spareBit)]);
          }
        }
      return 0;
      }

    bool free(void *ptr)
      {
      if(contains(ptr))
        {
        // always positive
        xsize index = ( (char*)ptr - (char*)_memory ) / _size;
        xsize block = index / 32;
        xsize blockIndex = index % 32;

        xAssert((_masks[block]&(1<<blockIndex)) != false);

        // set to 0
        _masks[block] = ~((~_masks[block])|(1<<blockIndex));
        xAssert((_masks[block]&(1<<blockIndex)) == false);

        return true;
        }
      return false;
      }

    bool empty() const
      {
      for(xsize i=0, s=(_count/32); i<s; ++i)
        {
        if(_masks[i] != 0)
          {
          return false;
          }
        }
      return true;
      }

    bool contains(void *ptr) const
      {
      if(ptr < _memory)
        {
        return false;
        }
      if(ptr >= (_memory + (_count*_size)))
        {
        return false;
        }
      return true;
      }

  private:
    xuint8 findFirstSpareBit(xuint8 mask)
      {
      for(xuint8 i=0; i<8; ++i)
        {
        if((Bit(i)&mask) == false)
          {
          return i;
          }
        }
      xAssert(0);
      return 8;
      }

    xsize _count;
    xsize _size;
    xuint32 *_masks;
    xuint8 *_memory;
    xuint8 *_alloc;
    XAllocatorBase *_allocator;
    };

  XFixedSizeBucketAllocator(xsize s, xsize d=128, xsize e=1024, XAllocatorBase *allocator=XGlobalAllocator::instance())
      : _freePtr(0), _allocator(allocator), _size(s), _defaultSize(d), _expandSize(e), _first(0)
    {
    xAssert(_allocator);

    if(d != 0)
      {
      _first = xAllocateAndConstruct(_allocator, Bucket, _allocator, _size, _defaultSize);
      }
    }

  ~XFixedSizeBucketAllocator()
    {
    Bucket *b = _first;
    while(b)
      {
      Bucket *b2 = b->next();
      xDestroyAndFree(_allocator, Bucket, b);
      b = b2;
      }
    }

  void *alloc()
    {
    void *newMem = 0;

    Bucket *b = _freePtr ? _freePtr : _first;
    while(b)
      {
      newMem = b->alloc();
      if(newMem)
        {
        return newMem;
        }
      else
        {
        _freePtr = b;
        }
      b = b->next();
      }

    Bucket* newBlock = xAllocateAndConstruct(_allocator, Bucket, _allocator, _size, _expandSize);

    // add the new bucket to the end.
    if(_first)
      {
      Bucket *b = _first;
      while(b && b->next())
        {
        b = b->next();
        }
      b->setNext(newBlock);
      }
    else
      {
      _first = newBlock;
      }

    return newBlock->alloc();
    }

  bool free(void *ptr)
    {
    bool hitFreePtr = false;
    Bucket *b = _first;
    while(b)
      {
      if(b == _freePtr)
        {
        hitFreePtr = true;
        }

      if(b->free(ptr))
        {
        if(!hitFreePtr)
          {
          _freePtr = b;
          }
        return true;
        }
      b = b->next();
      }
    return false;
    }

  bool empty() const
    {
    Bucket *b = _first;
    while(b)
      {
      if(!b->empty())
        {
        return false;
        }
      b = b->next();
      }
    return true;
    }

  bool contains(void *ptr) const
    {
    Bucket *b = _first;
    while(b)
      {
      if(b->contains(ptr))
        {
        return true;
        }
      b = b->next();
      }
    return false;
    }

  xsize size() const
    {
    return _size;
    }

private:
  X_DISABLE_COPY(XFixedSizeBucketAllocator);
  Bucket *_freePtr;
  xsize _size;
  xsize _defaultSize;
  xsize _expandSize;
  Bucket * _first;
  XAllocatorBase *_allocator;
  };

class XBucketAllocator : public XAllocatorBase
  {
public:
  XBucketAllocator(xsize d=128, xsize e=1024, XAllocatorBase *alloc=XGlobalAllocator::instance())
      : _defaultSize(d), _expandSize(e), _allocator(alloc), _internal(alloc)
    {
    xAssert(_allocator);
    }

  ~XBucketAllocator()
    {
    HashType::iterator i = _internal.begin();
    HashType::iterator e = _internal.end();
    while (i != e)
      {
      xDestroyAndFree(_allocator, XFixedSizeBucketAllocator, i.value());
      ++i;
      }
    }

  void *alloc(xsize size, xsize alignment=X_ALIGN_BYTE_COUNT)
    {
    size = X_ROUND_TO_SPECIFIC_ALIGNMENT(xsize, size, alignment);
    X_MEMORY_LOGGER_ALLOC(xTotalBucketAllocatorSize, size);

    XFixedSizeBucketAllocator *b = _internal.value(size, 0);
    if(!b)
      {
      b = xAllocateAndConstruct(_allocator, XFixedSizeBucketAllocator, size, _defaultSize, _expandSize, _allocator);
      _internal.insert(size, b);
      }

    return b->alloc();
    }

  void free(void *ptr)
    {
    HashType::iterator i = _internal.begin();
    HashType::iterator e = _internal.end();
    while (i != e)
      {
      if(i.value()->contains(ptr))
        {
        X_MEMORY_LOGGER_FREE(xTotalBucketAllocatorSize, i.value()->size());
        xVerify(i.value()->free(ptr));
        return;
        }
      ++i;
      }
    xAssertFail();
    }

  bool empty() const
    {
    HashType::const_iterator i = _internal.constBegin();
    HashType::const_iterator e = _internal.constEnd();
    while (i != e)
      {
      if(!i.value()->empty())
        {
        return false;
        }
      ++i;
      }
    return true;
    }

private:
  X_DISABLE_COPY(XBucketAllocator);
  xsize _defaultSize;
  xsize _expandSize;

  typedef XUnorderedMap <xsize, XFixedSizeBucketAllocator *> HashType;
  HashType _internal;

  XAllocatorBase *_allocator;
  };

#endif // XRANDOMACCESSBLOCKALLOCATOR_H
